
2024-07-09T00:55:36.509496
In Hunk:@@ -11,6 +11,19 @@
 1     <div id="ui">
 2         <div id="score">Score: 0</div>
+    <div id="leaderboard-container">
+        <div id="leaderboard-handle">Leaderboard</div>
+        <table id="leaderboard">
+            <thead>
+                <tr>
+                    <th id="rank-header">Rank</th>
+                    <th>Name</th>
+                    <th id="score-header">Score</th>
+                    <th>Time</th>
+                    <th id="tph-header">TPH</th>
+                </tr>
+            </thead>
+            <tbody></tbody>
+        </table>
+    </div>
 4     <script src="main.js"></script>
 5 </body>
 6 </html>
, there was at least one mismatch.

In @@ -25,3 +25,31 @@
 5 
 6 #leaderboard-container {
 7     position: fixed;
 8     top: 0;
 9     left: -300px;
 0     width: 300px;
 1     background: rgba(255, 255, 255, 0.9);
 2     border-right: 1px solid #000;
 3     transition: left 0.3s ease;
 4     z-index: 20;
 5 }
 6 
 7 #leaderboard-handle {
 8     position: absolute;
 9     top: 0;
 0     right: -50px;
 1     width: 50px;
 2     height: 50px;
 3     background: #000;
 4     color: #fff;
 5     display: flex;
 6     align-items: center;
 7     justify-content: center;
 8     cursor: pointer;
 9 }
 0 
 1 #leaderboard {
 2     width: 100%;
 3     border-collapse: collapse;
 4 }
 5 
 6 #leaderboard th, #leaderboard td {
 7     border: 1px solid #000;
 8     padding: 5px;
 9     text-align: left;
 0 }
 1 
 2 #leaderboard th {
 3     cursor: pointer;
 4 }
:The starting line of the diff @@ -25,3 +25,31 @@
 5 
 6 #leaderboard-container {
 7     position: fixed;
 8     top: 0;
 9     left: -300px;
 0     width: 300px;
 1     background: rgba(255, 255, 255, 0.9);
 2     border-right: 1px solid #000;
 3     transition: left 0.3s ease;
 4     z-index: 20;
 5 }
 6 
 7 #leaderboard-handle {
 8     position: absolute;
 9     top: 0;
 0     right: -50px;
 1     width: 50px;
 2     height: 50px;
 3     background: #000;
 4     color: #fff;
 5     display: flex;
 6     align-items: center;
 7     justify-content: center;
 8     cursor: pointer;
 9 }
 0 
 1 #leaderboard {
 2     width: 100%;
 3     border-collapse: collapse;
 4 }
 5 
 6 #leaderboard th, #leaderboard td {
 7     border: 1px solid #000;
 8     padding: 5px;
 9     text-align: left;
 0 }
 1 
 2 #leaderboard th {
 3     cursor: pointer;
 4 }
 does not exist in the code

In Hunk:@@ -12,6 +12,7 @@
 2     view_top: 0,
 3     view_bottom: 0,
 4     view_left: 0,
 5     view_right: 0
 6 };
 7 
 8 function log(...args) {
 9     console.log(new Date().toISOString().substring(11, 23), ...args);
 0 }
 1 
 2 let mouseX = 0;
 3 let mouseY = 0;
 4 let isDragging = false;
 5 let lastPosX = 0;
 6 let lastPosY = 0;
 7 
 8 canvas.addEventListener('mousedown', (event) => {
 9     isDragging = true;
 0     lastPosX = event.clientX;
 1     lastPosY = event.clientY;
 2 });
 3 
 4 function handleMove(event) {
 5     if (isDragging) {
 6         const deltaX = event.clientX - lastPosX;
 7         const deltaY = event.clientY - lastPosY;
 8         gameState.view_left -= deltaX;
 9         gameState.view_right -= deltaX;
 0         gameState.view_top -= deltaY;
 1         gameState.view_bottom -= deltaY;
 2         lastPosX = event.clientX;
 3         lastPosY = event.clientY;
 4         safeSend(ws, JSON.stringify({
 5             action_type: 'Update',
 6             area_to_update: getVisibleArea()
 7         }));
 8         renderGame(true);
 9     } else {
 0         mouseX = event.clientX;
 1         mouseY = event.clientY;
 2     }
 3 }
 4 
 5 canvas.addEventListener('mousemove', handleMove);
 6 
 7 canvas.addEventListener('mouseup', () => {
 8     isDragging = false;
 9 });
 0 
 1 canvas.addEventListener('touchstart', (event) => {
 2     const touch = event.touches[0];
 3     isDragging = true;
 4     lastPosX = touch.clientX;
 5     lastPosY = touch.clientY;
 6 }, {passive: true});
 7 
 8 canvas.addEventListener('touchmove', (event) => {
 9     handleMove(event.touches[0]);
 0 }, {passive: true});
 1 
 2 canvas.addEventListener('touchend', () => {
 3     isDragging = false;
 4 });
 5 
 6 const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
 7 const ws = new WebSocket(`${wsProtocol}//${window.location.host}/ws`);
 8 
 9 // Check WebSocket connection state before sending a message
 0 function safeSend(ws, message) {
 1     if (ws.readyState === WebSocket.OPEN) {
 2         ws.send(message);
 3         log('Message sent to server', message);
 4     } else {
 5         console.error('WebSocket is not open. ReadyState:', ws.readyState);
 6     }
 7 }
 8 
 9 ws.addEventListener('open', () => {
 0     const horizontalTiles = Math.floor(canvas.width / TILE_SIZE);
 1     const verticalTiles = Math.floor(canvas.height / TILE_SIZE);
 2 
 3     safeSend(ws, JSON.stringify({
 4         action_type: 'Join',
 5         visible_area: [
 6             [Math.floor(-horizontalTiles / 2), Math.ceil(-verticalTiles / 2)],  // left, top
 7             [Math.floor(horizontalTiles / 2), Math.ceil(verticalTiles / 2)]  // right, bottom
 8         ]
 9     }));
 00 });
 01 
 02 // Handle WebSocket closure and errors
 03 ws.addEventListener('close', (event) => {
 04     log('WebSocket closed:', event);
 05 });
 06 
 07 ws.addEventListener('error', (error) => {
 08     console.error('WebSocket error:', error);
 09 });
 10 
 11 function getVisibleArea() {
 12     return [
 13         [Math.floor(gameState.view_left / TILE_SIZE), Math.floor(gameState.view_top / TILE_SIZE)],
 14         [Math.ceil(gameState.view_right / TILE_SIZE), Math.ceil(gameState.view_bottom / TILE_SIZE)]
 15     ];
 16 }
 17 
 18 function getTileUnderMouse() {
 19     return [
 20         Math.floor((gameState.view_left + mouseX) / TILE_SIZE),
 21         Math.floor((gameState.view_top + mouseY) / TILE_SIZE)
 22     ]
 23 }
 24 
 25 function handle_click(event) {
 26     log('Click event registered, mouse position:', mouseX, mouseY, 'event:', event.type);
 27     safeSend(ws, JSON.stringify({
 28         action_type: 'Uncover',
 29         player_id: gameState.player_id,
 30         token: gameState.token,
 31         position: getTileUnderMouse(),
 32         visible_area: getVisibleArea()
 33     }));
 34 }
 35 
 36 canvas.addEventListener('click', handle_click);
 37 document.addEventListener('keyup', handle_click);
 38 
 39 ws.onmessage = (event) => {
 40     const parsedResponse = JSON.parse(event.data);
 41     const responseType = Object.keys(parsedResponse)[0];
 42     const response = parsedResponse[responseType];
 43     log('Message received from server', event.data.length, 'bytes', response);
 44     Object.entries(response.tiles).forEach(([positionString, tile]) => {
 45         console.log(positionString, tile);
 46         gameState.tiles[positionString] = tile;
 47     });
 48     switch (responseType) {
 49         case 'Joined':
 50             handleJoinResponse(response);
 51             updatePlayers(response);
 52             renderGame(true);
 53             break;
 54         case 'Updated':
 55             renderGame(true);
 56             break;
 57         case 'Uncovered':
 58             updatePlayers(response);
 59             renderGame(false);
 60             break;
 61         case 'Error':
 62             console.error('Error:', response.message);
 63             break;
 64         default:
 65             console.error('Unknown response type:', responseType);
 66     }
 67 }
 68 
 69 function updatePlayers(response) {
 70     Object.entries(response.players).forEach(([playerId, player]) => {
 71         gameState.players[playerId] = player;
 72     });
 73     updateLeaderboard();
 74 }
 75 
 76 function handleJoinResponse(response) {
 77     gameState.playing = true;
 78     gameState.player_id = response.player_id;
 79     gameState.token = response.token;
 80     gameState.view_left = TILE_SIZE * response.update_area[0][0];
 81     gameState.view_top = TILE_SIZE * response.update_area[0][1];
 82     gameState.view_right = TILE_SIZE * response.update_area[1][0];
 83     gameState.view_bottom = TILE_SIZE * response.update_area[1][1];
 84 }
 85 
 86 function renderGame(clear) {
 87     if (clear) {
 88         const matrix = new DOMMatrix().translate(-gameState.view_left, -gameState.view_top)
 89         coveredTilePattern.setTransform(matrix);
 90         ctx.fillStyle = coveredTilePattern;
 91         ctx.fillRect(0, 0, canvas.width, canvas.height);
 92     }
 93     Object.entries(gameState.tiles).forEach(([position, tile]) => {
 94         const [x, y] = JSON.parse(`[${position}]`);
 95         const left = x * TILE_SIZE - gameState.view_left;
 96         if (left + TILE_SIZE < 0 || left > canvas.width) return;
 97         const top = y * TILE_SIZE - gameState.view_top;
 98         if (top + TILE_SIZE < 0 || top > canvas.height) return;
 99         const player = gameState.players[tile.player_id];
 00         // Sometimes the player is not found, this is for alerting the tester about it:
 01         if (!player) alert('Player not found:', tile.player_id);
 02         ctx.fillStyle = '#808080';
 03         ctx.fillRect(left, top, TILE_SIZE, TILE_SIZE);
 04         ctx.fillStyle = tile.is_mine ? 'red' : player ? player.color : 'black';
 05         ctx.fillRect(left + 1, top + 1, TILE_SIZE - 2, TILE_SIZE - 2);
 06         if (!tile.is_mine && tile.adjacent_mines > 0) {
 07             ctx.fillStyle = 'black';
 08             ctx.textAlign = 'center';
 09             ctx.font = `bold ${3 * TILE_SIZE / 4}px Impact`;
 10             ctx.fillText(tile.adjacent_mines, left + TILE_SIZE / 2, top + 3 * TILE_SIZE / 4);
 11         }
 12     });
 13     Object.entries(gameState.players).forEach(([playerId, player]) => {
 14         ctx.fillStyle = player.color;
 15         ctx.fillText(
 16             `Player ${playerId}: ${player.score}`,
 17             TILE_SIZE / 2,
 18             TILE_SIZE * playerId
 19         );
 20     });
 21 }
 22 
 23 const coveredTileCanvas = new OffscreenCanvas(TILE_SIZE, TILE_SIZE);
 24 const coveredTileCtx = coveredTileCanvas.getContext('2d');
 25 coveredTileCtx.fillStyle = '#ffffff';
 26 coveredTileCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
 27 coveredTileCtx.fillStyle = '#808080';
 28 coveredTileCtx.fillRect(2, 2, TILE_SIZE - 2, TILE_SIZE - 2);
 29 coveredTileCtx.fillStyle = '#c0c0c0';
 30 coveredTileCtx.fillRect(2, 2, TILE_SIZE - 4, TILE_SIZE - 4);
 31 coveredTileCtx.strokeStyle = '#c0c0c0';
 32 coveredTileCtx.lineWidth = 2.0;
 33 coveredTileCtx.beginPath();
 34 coveredTileCtx.moveTo(TILE_SIZE + 0.5, -0.5);
 35 coveredTileCtx.lineTo(-0.5, TILE_SIZE + 0.5);
 36 coveredTileCtx.stroke();
 37 const coveredTilePattern = ctx.createPattern(coveredTileCanvas, 'repeat');
 38 
 39 // Leaderboard logic
 40 const leaderboardContainer = document.getElementById('leaderboard-container');
 41 const leaderboardHandle = document.getElementById('leaderboard-handle');
 42 const leaderboardTable = document.getElementById('leaderboard').getElementsByTagName('tbody')[0];
 43 let sortBy = 'score'; // Default sorting by score
 44 let sortOrder = 'asc'; // Default sorting order ascending
 45 
 46 leaderboardHandle.addEventListener('click', () => {
 47     if (leaderboardContainer.style.left === '0px') {
 48         leaderboardContainer.style.left = '-300px';
 49     } else {
 50         leaderboardContainer.style.left = '0px';
 51     }
 52 });
 53 
 54 document.getElementById('score-header').addEventListener('click', () => {
 55     sortBy = 'score';
 56     sortOrder = sortOrder === 'asc' ? 'desc' : 'asc';
 57     updateLeaderboard();
 58 });
 59 
 60 document.getElementById('tph-header').addEventListener('click', () => {
 61     sortBy = 'tph';
 62     sortOrder = sortOrder === 'asc' ? 'desc' : 'asc';
 63     updateLeaderboard();
 64 });
 65 
 66 function updateLeaderboard() {
 67     const players = Object.values(gameState.players);
 68     players.forEach(player => {
 69         player.tph = player.score / ((Date.now() - player.joinTime) / 3600000); // Calculate TPH
 70     });
 71     players.sort((a, b) => {
 72         if (sortBy === 'score') {
 73             return sortOrder === 'asc' ? a.score - b.score : b.score - a.score;
 74         } else {
 75             return sortOrder === 'asc' ? a.tph - b.tph : b.tph - a.tph;
 76         }
 77     });
 78 
 79     const visiblePlayers = getVisiblePlayers(players);
 80     leaderboardTable.innerHTML = '';
 81     visiblePlayers.forEach((player, index) => {
 82         const row = leaderboardTable.insertRow();
 83         row.insertCell(0).innerText = index + 1; // Rank
 84         row.insertCell(1).innerText = player.name; // Name
 85         row.insertCell(2).innerText = player.score; // Score
 86         row.insertCell(3).innerText = formatTime(player.joinTime); // Time
 87         row.insertCell(4).innerText = player.tph.toFixed(2); // TPH
 88     });
 89 }
 90 
 91 function getVisiblePlayers(players) {
 92     const visiblePlayers = [];
 93     const currentPlayer = gameState.players[gameState.player_id];
 94     const currentPlayerIndex = players.findIndex(player => player.id === currentPlayer.id);
 95 
 96     if (currentPlayerIndex > 0) {
 97         visiblePlayers.push(players[currentPlayerIndex - 1]); // Player above
 98     }
 99     visiblePlayers.push(currentPlayer); // Current player
 00     if (currentPlayerIndex < players.length - 1) {
 01         visiblePlayers.push(players[currentPlayerIndex + 1]); // Player below
 02     }
 03     visiblePlayers.push(players[0]); // Top player
 04 
 05     const visibleArea = getVisibleArea();
 06     players.forEach(player => {
 07         if (player.id !== currentPlayer.id && isPlayerVisible(player, visibleArea)) {
 08             visiblePlayers.push(player);
 09         }
 10     });
 11 
 12     return visiblePlayers;
 13 }
 14 
 15 function isPlayerVisible(player, visibleArea) {
 16     return Object.values(gameState.tiles).some(tile => {
 17         return tile.player_id === player.id &&
 18             tile.x >= visibleArea[0][0] && tile.x <= visibleArea[1][0] &&
 19             tile.y >= visibleArea[0][1] && tile.y <= visibleArea[1][1];
 20     });
 21 }
 22 
 23 function formatTime(joinTime) {
 24     const totalSeconds = Math.floor((Date.now() - joinTime) / 1000);
 25     const hours = Math.floor(totalSeconds / 3600);
 26     const minutes = Math.floor((totalSeconds % 3600) / 60);
 27     const seconds = totalSeconds % 60;
 28     return `${hours}h ${minutes}m ${seconds}s`;
 29 }
, there was at least one mismatch.

2024-07-09T00:56:31.503736
In Hunk:@@ -10,6 +10,19 @@
 0     <canvas id="gameCanvas"></canvas>
 1     <div id="ui">
 2         <div id="score">Score: 0</div>
+        <div id="leaderboard-container">
+            <div id="leaderboard-handle">Leaderboard</div>
+            <table id="leaderboard">
+                <thead>
+                    <tr>
+                        <th id="rank-header">Rank</th>
+                        <th>Name</th>
+                        <th id="score-header">Score</th>
+                        <th>Time</th>
+                        <th id="tph-header">TPH</th>
+                    </tr>
+                </thead>
+                <tbody></tbody>
+            </table>
+        </div>
 3     </div>
 4     <script src="main.js"></script>
 5 </body>
, there was at least one mismatch.

In @@ -24,3 +24,31 @@
 4 }
 5 
 6 #leaderboard-container {
 7     position: fixed;
 8     top: 0;
 9     left: -300px;
 0     width: 300px;
 1     background: rgba(255, 255, 255, 0.9);
 2     border-right: 1px solid #000;
 3     transition: left 0.3s ease;
 4     z-index: 20;
 5 }
 6 
 7 #leaderboard-handle {
 8     position: absolute;
 9     top: 0;
 0     right: -50px;
 1     width: 50px;
 2     height: 50px;
 3     background: #000;
 4     color: #fff;
 5     display: flex;
 6     align-items: center;
 7     justify-content: center;
 8     cursor: pointer;
 9 }
 0 
 1 #leaderboard {
 2     width: 100%;
 3     border-collapse: collapse;
 4 }
 5 
 6 #leaderboard th, #leaderboard td {
 7     border: 1px solid #000;
 8     padding: 5px;
 9     text-align: left;
 0 }
 1 
 2 #leaderboard th {
 3     cursor: pointer;
 4 }
:The starting line of the diff @@ -24,3 +24,31 @@
 4 }
 5 
 6 #leaderboard-container {
 7     position: fixed;
 8     top: 0;
 9     left: -300px;
 0     width: 300px;
 1     background: rgba(255, 255, 255, 0.9);
 2     border-right: 1px solid #000;
 3     transition: left 0.3s ease;
 4     z-index: 20;
 5 }
 6 
 7 #leaderboard-handle {
 8     position: absolute;
 9     top: 0;
 0     right: -50px;
 1     width: 50px;
 2     height: 50px;
 3     background: #000;
 4     color: #fff;
 5     display: flex;
 6     align-items: center;
 7     justify-content: center;
 8     cursor: pointer;
 9 }
 0 
 1 #leaderboard {
 2     width: 100%;
 3     border-collapse: collapse;
 4 }
 5 
 6 #leaderboard th, #leaderboard td {
 7     border: 1px solid #000;
 8     padding: 5px;
 9     text-align: left;
 0 }
 1 
 2 #leaderboard th {
 3     cursor: pointer;
 4 }
 does not exist in the code

In Hunk:@@ -15,6 +16,7 @@
 6     view_right: 0
 7 };
 8 
 9 function log(...args) {
 0     console.log(new Date().toISOString().substring(11, 23), ...args);
 1 }
 2 
 3 let mouseX = 0;
 4 let mouseY = 0;
 5 let isDragging = false;
 6 let lastPosX = 0;
 7 let lastPosY = 0;
 8 
 9 canvas.addEventListener('mousedown', (event) => {
 0     isDragging = true;
 1     lastPosX = event.clientX;
 2     lastPosY = event.clientY;
 3 });
 4 
 5 function handleMove(event) {
 6     if (isDragging) {
 7         const deltaX = event.clientX - lastPosX;
 8         const deltaY = event.clientY - lastPosY;
 9         gameState.view_left -= deltaX;
 0         gameState.view_right -= deltaX;
 1         gameState.view_top -= deltaY;
 2         gameState.view_bottom -= deltaY;
 3         lastPosX = event.clientX;
 4         lastPosY = event.clientY;
 5         safeSend(ws, JSON.stringify({
 6             action_type: 'Update',
 7             area_to_update: getVisibleArea()
 8         }));
 9         renderGame(true);
 0     } else {
 1         mouseX = event.clientX;
 2         mouseY = event.clientY;
 3     }
 4 }
 5 
 6 canvas.addEventListener('mousemove', handleMove);
 7 
 8 canvas.addEventListener('mouseup', () => {
 9     isDragging = false;
 0 });
 1 
 2 canvas.addEventListener('touchstart', (event) => {
 3     const touch = event.touches[0];
 4     isDragging = true;
 5     lastPosX = touch.clientX;
 6     lastPosY = touch.clientY;
 7 }, {passive: true});
 8 
 9 canvas.addEventListener('touchmove', (event) => {
 0     handleMove(event.touches[0]);
 1 }, {passive: true});
 2 
 3 canvas.addEventListener('touchend', () => {
 4     isDragging = false;
 5 });
 6 
 7 const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
 8 const ws = new WebSocket(`${wsProtocol}//${window.location.host}/ws`);
 9 
 0 // Check WebSocket connection state before sending a message
 1 function safeSend(ws, message) {
 2     if (ws.readyState === WebSocket.OPEN) {
 3         ws.send(message);
 4         log('Message sent to server', message);
 5     } else {
 6         console.error('WebSocket is not open. ReadyState:', ws.readyState);
 7     }
 8 }
 9 
 0 ws.addEventListener('open', () => {
 1     const horizontalTiles = Math.floor(canvas.width / TILE_SIZE);
 2     const verticalTiles = Math.floor(canvas.height / TILE_SIZE);
 3 
 4     safeSend(ws, JSON.stringify({
 5         action_type: 'Join',
 6         visible_area: [
 7             [Math.floor(-horizontalTiles / 2), Math.ceil(-verticalTiles / 2)],  // left, top
 8             [Math.floor(horizontalTiles / 2), Math.ceil(verticalTiles / 2)]  // right, bottom
 9         ]
 00     }));
 01 });
 02 
 03 // Handle WebSocket closure and errors
 04 ws.addEventListener('close', (event) => {
 05     log('WebSocket closed:', event);
 06 });
 07 
 08 ws.addEventListener('error', (error) => {
 09     console.error('WebSocket error:', error);
 10 });
 11 
 12 function getVisibleArea() {
 13     return [
 14         [Math.floor(gameState.view_left / TILE_SIZE), Math.floor(gameState.view_top / TILE_SIZE)],
 15         [Math.ceil(gameState.view_right / TILE_SIZE), Math.ceil(gameState.view_bottom / TILE_SIZE)]
 16     ];
 17 }
 18 
 19 function getTileUnderMouse() {
 20     return [
 21         Math.floor((gameState.view_left + mouseX) / TILE_SIZE),
 22         Math.floor((gameState.view_top + mouseY) / TILE_SIZE)
 23     ]
 24 }
 25 
 26 function handle_click(event) {
 27     log('Click event registered, mouse position:', mouseX, mouseY, 'event:', event.type);
 28     safeSend(ws, JSON.stringify({
 29         action_type: 'Uncover',
 30         player_id: gameState.player_id,
 31         token: gameState.token,
 32         position: getTileUnderMouse(),
 33         visible_area: getVisibleArea()
 34     }));
 35 }
 36 
 37 canvas.addEventListener('click', handle_click);
 38 document.addEventListener('keyup', handle_click);
 39 
 40 ws.onmessage = (event) => {
 41     const parsedResponse = JSON.parse(event.data);
 42     const responseType = Object.keys(parsedResponse)[0];
 43     const response = parsedResponse[responseType];
 44     log('Message received from server', event.data.length, 'bytes', response);
 45     Object.entries(response.tiles).forEach(([positionString, tile]) => {
 46         console.log(positionString, tile);
 47         gameState.tiles[positionString] = tile;
 48     });
 49     switch (responseType) {
 50         case 'Joined':
 51             handleJoinResponse(response);
 52             updatePlayers(response);
 53             renderGame(true);
 54             break;
 55         case 'Updated':
 56             renderGame(true);
 57             break;
 58         case 'Uncovered':
 59             updatePlayers(response);
 60             renderGame(false);
 61             break;
 62         case 'Error':
 63             console.error('Error:', response.message);
 64             break;
 65         default:
 66             console.error('Unknown response type:', responseType);
 67     }
 68 }
 69 
 70 function updatePlayers(response) {
 71     Object.entries(response.players).forEach(([playerId, player]) => {
 72         gameState.players[playerId] = player;
 73     });
 74     updateLeaderboard();
 75 }
 76 
 77 function handleJoinResponse(response) {
 78     gameState.playing = true;
 79     gameState.player_id = response.player_id;
 80     gameState.token = response.token;
 81     gameState.view_left = TILE_SIZE * response.update_area[0][0];
 82     gameState.view_top = TILE_SIZE * response.update_area[0][1];
 83     gameState.view_right = TILE_SIZE * response.update_area[1][0];
 84     gameState.view_bottom = TILE_SIZE * response.update_area[1][1];
 85 }
 86 
 87 function renderGame(clear) {
 88     if (clear) {
 89         const matrix = new DOMMatrix().translate(-gameState.view_left, -gameState.view_top)
 90         coveredTilePattern.setTransform(matrix);
 91         ctx.fillStyle = coveredTilePattern;
 92         ctx.fillRect(0, 0, canvas.width, canvas.height);
 93     }
 94     Object.entries(gameState.tiles).forEach(([position, tile]) => {
 95         const [x, y] = JSON.parse(`[${position}]`);
 96         const left = x * TILE_SIZE - gameState.view_left;
 97         if (left + TILE_SIZE < 0 || left > canvas.width) return;
 98         const top = y * TILE_SIZE - gameState.view_top;
 99         if (top + TILE_SIZE < 0 || top > canvas.height) return;
 00         const player = gameState.players[tile.player_id];
 01         // Sometimes the player is not found, this is for alerting the tester about it:
 02         if (!player) alert('Player not found:', tile.player_id);
 03         ctx.fillStyle = '#808080';
 04         ctx.fillRect(left, top, TILE_SIZE, TILE_SIZE);
 05         ctx.fillStyle = tile.is_mine ? 'red' : player ? player.color : 'black';
 06         ctx.fillRect(left + 1, top + 1, TILE_SIZE - 2, TILE_SIZE - 2);
 07         if (!tile.is_mine && tile.adjacent_mines > 0) {
 08             ctx.fillStyle = 'black';
 09             ctx.textAlign = 'center';
 10             ctx.font = `bold ${3 * TILE_SIZE / 4}px Impact`;
 11             ctx.fillText(tile.adjacent_mines, left + TILE_SIZE / 2, top + 3 * TILE_SIZE / 4);
 12         }
 13     });
 14 }
 15 
 16 const coveredTileCanvas = new OffscreenCanvas(TILE_SIZE, TILE_SIZE);
 17 const coveredTileCtx = coveredTileCanvas.getContext('2d');
 18 coveredTileCtx.fillStyle = '#ffffff';
 19 coveredTileCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
 20 coveredTileCtx.fillStyle = '#808080';
 21 coveredTileCtx.fillRect(2, 2, TILE_SIZE - 2, TILE_SIZE - 2);
 22 coveredTileCtx.fillStyle = '#c0c0c0';
 23 coveredTileCtx.fillRect(2, 2, TILE_SIZE - 4, TILE_SIZE - 4);
 24 coveredTileCtx.strokeStyle = '#c0c0c0';
 25 coveredTileCtx.lineWidth = 2.0;
 26 coveredTileCtx.beginPath();
 27 coveredTileCtx.moveTo(TILE_SIZE + 0.5, -0.5);
 28 coveredTileCtx.lineTo(-0.5, TILE_SIZE + 0.5);
 29 coveredTileCtx.stroke();
 30 const coveredTilePattern = ctx.createPattern(coveredTileCanvas, 'repeat');
 31 
 32 // Leaderboard logic
 33 const leaderboardContainer = document.getElementById('leaderboard-container');
 34 const leaderboardHandle = document.getElementById('leaderboard-handle');
 35 const leaderboardTable = document.getElementById('leaderboard').getElementsByTagName('tbody')[0];
 36 let sortBy = 'score'; // Default sorting by score
 37 let sortOrder = 'asc'; // Default sorting order ascending
 38 
 39 leaderboardHandle.addEventListener('click', () => {
 40     if (leaderboardContainer.style.left === '0px') {
 41         leaderboardContainer.style.left = '-300px';
 42     } else {
 43         leaderboardContainer.style.left = '0px';
 44     }
 45 });
 46 
 47 document.getElementById('score-header').addEventListener('click', () => {
 48     sortBy = 'score';
 49     sortOrder = sortOrder === 'asc' ? 'desc' : 'asc';
 50     updateLeaderboard();
 51 });
 52 
 53 document.getElementById('tph-header').addEventListener('click', () => {
 54     sortBy = 'tph';
 55     sortOrder = sortOrder === 'asc' ? 'desc' : 'asc';
 56     updateLeaderboard();
 57 });
 58 
 59 function updateLeaderboard() {
 60     const players = Object.values(gameState.players);
 61     players.forEach(player => {
 62         player.tph = player.score / ((Date.now() - player.joinTime) / 3600000); // Calculate TPH
 63     });
 64     players.sort((a, b) => {
 65         if (sortBy === 'score') {
 66             return sortOrder === 'asc' ? a.score - b.score : b.score - a.score;
 67         } else {
 68             return sortOrder === 'asc' ? a.tph - b.tph : b.tph - a.tph;
 69         }
 70     });
 71 
 72     const visiblePlayers = getVisiblePlayers(players);
 73     leaderboardTable.innerHTML = '';
 74     visiblePlayers.forEach((player, index) => {
 75         const row = leaderboardTable.insertRow();
 76         row.insertCell(0).innerText = index + 1; // Rank
 77         row.insertCell(1).innerText = player.name; // Name
 78         row.insertCell(2).innerText = player.score; // Score
 79         row.insertCell(3).innerText = formatTime(player.joinTime); // Time
 80         row.insertCell(4).innerText = player.tph.toFixed(2); // TPH
 81     });
 82 }
 83 
 84 function getVisiblePlayers(players) {
 85     const visiblePlayers = [];
 86     const currentPlayer = gameState.players[gameState.player_id];
 87     const currentPlayerIndex = players.findIndex(player => player.id === currentPlayer.id);
 88 
 89     if (currentPlayerIndex > 0) {
 90         visiblePlayers.push(players[currentPlayerIndex - 1]); // Player above
 91     }
 92     visiblePlayers.push(currentPlayer); // Current player
 93     if (currentPlayerIndex < players.length - 1) {
 94         visiblePlayers.push(players[currentPlayerIndex + 1]); // Player below
 95     }
 96     visiblePlayers.push(players[0]); // Top player
 97 
 98     const visibleArea = getVisibleArea();
 99     players.forEach(player => {
 00         if (player.id !== currentPlayer.id && isPlayerVisible(player, visibleArea)) {
 01             visiblePlayers.push(player);
 02         }
 03     });
 04 
 05     return visiblePlayers;
 06 }
 07 
 08 function isPlayerVisible(player, visibleArea) {
 09     return Object.values(gameState.tiles).some(tile => {
 10         return tile.player_id === player.id &&
 11             tile.x >= visibleArea[0][0] && tile.x <= visibleArea[1][0] &&
 12             tile.y >= visibleArea[0][1] && tile.y <= visibleArea[1][1];
 13     });
 14 }
 15 
 16 function formatTime(joinTime) {
 17     const totalSeconds = Math.floor((Date.now() - joinTime) / 1000);
 18     const hours = Math.floor(totalSeconds / 3600);
 19     const minutes = Math.floor((totalSeconds % 3600) / 60);
 20     const seconds = totalSeconds % 60;
 21     return `${hours}h ${minutes}m ${seconds}s`;
 22 }
, there was at least one mismatch.

2024-07-09T00:57:25.582173
In Hunk:@@ -10,6 +10,19 @@
 0     <canvas id="gameCanvas"></canvas>
 1     <div id="ui">
 2         <div id="score">Score: 0</div>
+        <div id="leaderboard-container">
+            <div id="leaderboard-handle">Leaderboard</div>
+            <table id="leaderboard">
+                <thead>
+                    <tr>
+                        <th id="rank-header">Rank</th>
+                        <th>Name</th>
+                        <th id="score-header">Score</th>
+                        <th>Time</th>
+                        <th id="tph-header">TPH</th>
+                    </tr>
+                </thead>
+                <tbody></tbody>
+            </table>
+        </div>
 3     </div>
 4     <script src="main.js"></script>
 5 </body>
, there was at least one mismatch.

In @@ -24,3 +24,31 @@
 4 }
 5 
 6 #leaderboard-container {
 7     position: fixed;
 8     top: 0;
 9     left: -300px;
 0     width: 300px;
 1     background: rgba(255, 255, 255, 0.9);
 2     border-right: 1px solid #000;
 3     transition: left 0.3s ease;
 4     z-index: 20;
 5 }
 6 
 7 #leaderboard-handle {
 8     position: absolute;
 9     top: 0;
 0     right: -50px;
 1     width: 50px;
 2     height: 50px;
 3     background: #000;
 4     color: #fff;
 5     display: flex;
 6     align-items: center;
 7     justify-content: center;
 8     cursor: pointer;
 9 }
 0 
 1 #leaderboard {
 2     width: 100%;
 3     border-collapse: collapse;
 4 }
 5 
 6 #leaderboard th, #leaderboard td {
 7     border: 1px solid #000;
 8     padding: 5px;
 9     text-align: left;
 0 }
 1 
 2 #leaderboard th {
 3     cursor: pointer;
 4 }
:The starting line of the diff @@ -24,3 +24,31 @@
 4 }
 5 
 6 #leaderboard-container {
 7     position: fixed;
 8     top: 0;
 9     left: -300px;
 0     width: 300px;
 1     background: rgba(255, 255, 255, 0.9);
 2     border-right: 1px solid #000;
 3     transition: left 0.3s ease;
 4     z-index: 20;
 5 }
 6 
 7 #leaderboard-handle {
 8     position: absolute;
 9     top: 0;
 0     right: -50px;
 1     width: 50px;
 2     height: 50px;
 3     background: #000;
 4     color: #fff;
 5     display: flex;
 6     align-items: center;
 7     justify-content: center;
 8     cursor: pointer;
 9 }
 0 
 1 #leaderboard {
 2     width: 100%;
 3     border-collapse: collapse;
 4 }
 5 
 6 #leaderboard th, #leaderboard td {
 7     border: 1px solid #000;
 8     padding: 5px;
 9     text-align: left;
 0 }
 1 
 2 #leaderboard th {
 3     cursor: pointer;
 4 }
 does not exist in the code

In Hunk:@@ -15,6 +16,7 @@
 5     view_right: 0
 6 };
 7 
 8 function log(...args) {
 9     console.log(new Date().toISOString().substring(11, 23), ...args);
 0 }
 1 
 2 let mouseX = 0;
 3 let mouseY = 0;
 4 let isDragging = false;
 5 let lastPosX = 0;
 6 let lastPosY = 0;
 7 
 8 canvas.addEventListener('mousedown', (event) => {
 9     isDragging = true;
 0     lastPosX = event.clientX;
 1     lastPosY = event.clientY;
 2 });
 3 
 4 function handleMove(event) {
 5     if (isDragging) {
 6         const deltaX = event.clientX - lastPosX;
 7         const deltaY = event.clientY - lastPosY;
 8         gameState.view_left -= deltaX;
 9         gameState.view_right -= deltaX;
 0         gameState.view_top -= deltaY;
 1         gameState.view_bottom -= deltaY;
 2         lastPosX = event.clientX;
 3         lastPosY = event.clientY;
 4         safeSend(ws, JSON.stringify({
 5             action_type: 'Update',
 6             area_to_update: getVisibleArea()
 7         }));
 8         renderGame(true);
 9     } else {
 0         mouseX = event.clientX;
 1         mouseY = event.clientY;
 2     }
 3 }
 4 
 5 canvas.addEventListener('mousemove', handleMove);
 6 
 7 canvas.addEventListener('mouseup', () => {
 8     isDragging = false;
 9 });
 0 
 1 canvas.addEventListener('touchstart', (event) => {
 2     const touch = event.touches[0];
 3     isDragging = true;
 4     lastPosX = touch.clientX;
 5     lastPosY = touch.clientY;
 6 }, {passive: true});
 7 
 8 canvas.addEventListener('touchmove', (event) => {
 9     handleMove(event.touches[0]);
 0 }, {passive: true});
 1 
 2 canvas.addEventListener('touchend', () => {
 3     isDragging = false;
 4 });
 5 
 6 const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
 7 const ws = new WebSocket(`${wsProtocol}//${window.location.host}/ws`);
 8 
 9 // Check WebSocket connection state before sending a message
 0 function safeSend(ws, message) {
 1     if (ws.readyState === WebSocket.OPEN) {
 2         ws.send(message);
 3         log('Message sent to server', message);
 4     } else {
 5         console.error('WebSocket is not open. ReadyState:', ws.readyState);
 6     }
 7 }
 8 
 9 ws.addEventListener('open', () => {
 0     const horizontalTiles = Math.floor(canvas.width / TILE_SIZE);
 1     const verticalTiles = Math.floor(canvas.height / TILE_SIZE);
 2 
 3     safeSend(ws, JSON.stringify({
 4         action_type: 'Join',
 5         visible_area: [
 6             [Math.floor(-horizontalTiles / 2), Math.ceil(-verticalTiles / 2)],  // left, top
 7             [Math.floor(horizontalTiles / 2), Math.ceil(verticalTiles / 2)]  // right, bottom
 8         ]
 9     }));
 00 });
 01 
 02 // Handle WebSocket closure and errors
 03 ws.addEventListener('close', (event) => {
 04     log('WebSocket closed:', event);
 05 });
 06 
 07 ws.addEventListener('error', (error) => {
 08     console.error('WebSocket error:', error);
 09 });
 10 
 11 function getVisibleArea() {
 12     return [
 13         [Math.floor(gameState.view_left / TILE_SIZE), Math.floor(gameState.view_top / TILE_SIZE)],
 14         [Math.ceil(gameState.view_right / TILE_SIZE), Math.ceil(gameState.view_bottom / TILE_SIZE)]
 15     ];
 16 }
 17 
 18 function getTileUnderMouse() {
 19     return [
 20         Math.floor((gameState.view_left + mouseX) / TILE_SIZE),
 21         Math.floor((gameState.view_top + mouseY) / TILE_SIZE)
 22     ]
 23 }
 24 
 25 function handle_click(event) {
 26     log('Click event registered, mouse position:', mouseX, mouseY, 'event:', event.type);
 27     safeSend(ws, JSON.stringify({
 28         action_type: 'Uncover',
 29         player_id: gameState.player_id,
 30         token: gameState.token,
 31         position: getTileUnderMouse(),
 32         visible_area: getVisibleArea()
 33     }));
 34 }
 35 
 36 canvas.addEventListener('click', handle_click);
 37 document.addEventListener('keyup', handle_click);
 38 
 39 ws.onmessage = (event) => {
 40     const parsedResponse = JSON.parse(event.data);
 41     const responseType = Object.keys(parsedResponse)[0];
 42     const response = parsedResponse[responseType];
 43     log('Message received from server', event.data.length, 'bytes', response);
 44     Object.entries(response.tiles).forEach(([positionString, tile]) => {
 45         console.log(positionString, tile);
 46         gameState.tiles[positionString] = tile;
 47     });
 48     switch (responseType) {
 49         case 'Joined':
 50             handleJoinResponse(response);
 51             updatePlayers(response);
 52             renderGame(true);
 53             break;
 54         case 'Updated':
 55             renderGame(true);
 56             break;
 57         case 'Uncovered':
 58             updatePlayers(response);
 59             renderGame(false);
 60             break;
 61         case 'Error':
 62             console.error('Error:', response.message);
 63             break;
 64         default:
 65             console.error('Unknown response type:', responseType);
 66     }
 67 }
 68 
 69 function updatePlayers(response) {
 70     Object.entries(response.players).forEach(([playerId, player]) => {
 71         gameState.players[playerId] = player;
 72     });
 73     updateLeaderboard();
 74 }
 75 
 76 function handleJoinResponse(response) {
 77     gameState.playing = true;
 78     gameState.player_id = response.player_id;
 79     gameState.token = response.token;
 80     gameState.view_left = TILE_SIZE * response.update_area[0][0];
 81     gameState.view_top = TILE_SIZE * response.update_area[0][1];
 82     gameState.view_right = TILE_SIZE * response.update_area[1][0];
 83     gameState.view_bottom = TILE_SIZE * response.update_area[1][1];
 84 }
 85 
 86 function renderGame(clear) {
 87     if (clear) {
 88         const matrix = new DOMMatrix().translate(-gameState.view_left, -gameState.view_top)
 89         coveredTilePattern.setTransform(matrix);
 90         ctx.fillStyle = coveredTilePattern;
 91         ctx.fillRect(0, 0, canvas.width, canvas.height);
 92     }
 93     Object.entries(gameState.tiles).forEach(([position, tile]) => {
 94         const [x, y] = JSON.parse(`[${position}]`);
 95         const left = x * TILE_SIZE - gameState.view_left;
 96         if (left + TILE_SIZE < 0 || left > canvas.width) return;
 97         const top = y * TILE_SIZE - gameState.view_top;
 98         if (top + TILE_SIZE < 0 || top > canvas.height) return;
 99         const player = gameState.players[tile.player_id];
 00         // Sometimes the player is not found, this is for alerting the tester about it:
 01         if (!player) alert('Player not found:', tile.player_id);
 02         ctx.fillStyle = '#808080';
 03         ctx.fillRect(left, top, TILE_SIZE, TILE_SIZE);
 04         ctx.fillStyle = tile.is_mine ? 'red' : player ? player.color : 'black';
 05         ctx.fillRect(left + 1, top + 1, TILE_SIZE - 2, TILE_SIZE - 2);
 06         if (!tile.is_mine && tile.adjacent_mines > 0) {
 07             ctx.fillStyle = 'black';
 08             ctx.textAlign = 'center';
 09             ctx.font = `bold ${3 * TILE_SIZE / 4}px Impact`;
 10             ctx.fillText(tile.adjacent_mines, left + TILE_SIZE / 2, top + 3 * TILE_SIZE / 4);
 11         }
 12     });
 13 }
 14 
 15 const coveredTileCanvas = new OffscreenCanvas(TILE_SIZE, TILE_SIZE);
 16 const coveredTileCtx = coveredTileCanvas.getContext('2d');
 17 coveredTileCtx.fillStyle = '#ffffff';
 18 coveredTileCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
 19 coveredTileCtx.fillStyle = '#808080';
 20 coveredTileCtx.fillRect(2, 2, TILE_SIZE - 2, TILE_SIZE - 2);
 21 coveredTileCtx.fillStyle = '#c0c0c0';
 22 coveredTileCtx.fillRect(2, 2, TILE_SIZE - 4, TILE_SIZE - 4);
 23 coveredTileCtx.strokeStyle = '#c0c0c0';
 24 coveredTileCtx.lineWidth = 2.0;
 25 coveredTileCtx.beginPath();
 26 coveredTileCtx.moveTo(TILE_SIZE + 0.5, -0.5);
 27 coveredTileCtx.lineTo(-0.5, TILE_SIZE + 0.5);
 28 coveredTileCtx.stroke();
 29 const coveredTilePattern = ctx.createPattern(coveredTileCanvas, 'repeat');
 30 
 31 // Leaderboard logic
 32 const leaderboardContainer = document.getElementById('leaderboard-container');
 33 const leaderboardHandle = document.getElementById('leaderboard-handle');
 34 const leaderboardTable = document.getElementById('leaderboard').getElementsByTagName('tbody')[0];
 35 let sortBy = 'score'; // Default sorting by score
 36 let sortOrder = 'asc'; // Default sorting order ascending
 37 
 38 leaderboardHandle.addEventListener('click', () => {
 39     if (leaderboardContainer.style.left === '0px') {
 40         leaderboardContainer.style.left = '-300px';
 41     } else {
 42         leaderboardContainer.style.left = '0px';
 43     }
 44 });
 45 
 46 document.getElementById('score-header').addEventListener('click', () => {
 47     sortBy = 'score';
 48     sortOrder = sortOrder === 'asc' ? 'desc' : 'asc';
 49     updateLeaderboard();
 50 });
 51 
 52 document.getElementById('tph-header').addEventListener('click', () => {
 53     sortBy = 'tph';
 54     sortOrder = sortOrder === 'asc' ? 'desc' : 'asc';
 55     updateLeaderboard();
 56 });
 57 
 58 function updateLeaderboard() {
 59     const players = Object.values(gameState.players);
 60     players.forEach(player => {
 61         player.tph = player.score / ((Date.now() - player.joinTime) / 3600000); // Calculate TPH
 62     });
 63     players.sort((a, b) => {
 64         if (sortBy === 'score') {
 65             return sortOrder === 'asc' ? a.score - b.score : b.score - a.score;
 66         } else {
 67             return sortOrder === 'asc' ? a.tph - b.tph : b.tph - a.tph;
 68         }
 69     });
 70 
 71     const visiblePlayers = getVisiblePlayers(players);
 72     leaderboardTable.innerHTML = '';
 73     visiblePlayers.forEach((player, index) => {
 74         const row = leaderboardTable.insertRow();
 75         row.insertCell(0).innerText = index + 1; // Rank
 76         row.insertCell(1).innerText = player.name; // Name
 77         row.insertCell(2).innerText = player.score; // Score
 78         row.insertCell(3).innerText = formatTime(player.joinTime); // Time
 79         row.insertCell(4).innerText = player.tph.toFixed(2); // TPH
 80     });
 81 }
 82 
 83 function getVisiblePlayers(players) {
 84     const visiblePlayers = [];
 85     const currentPlayer = gameState.players[gameState.player_id];
 86     const currentPlayerIndex = players.findIndex(player => player.id === currentPlayer.id);
 87 
 88     if (currentPlayerIndex > 0) {
 89         visiblePlayers.push(players[currentPlayerIndex - 1]); // Player above
 90     }
 91     visiblePlayers.push(currentPlayer); // Current player
 92     if (currentPlayerIndex < players.length - 1) {
 93         visiblePlayers.push(players[currentPlayerIndex + 1]); // Player below
 94     }
 95     visiblePlayers.push(players[0]); // Top player
 96 
 97     const visibleArea = getVisibleArea();
 98     players.forEach(player => {
 99         if (player.id !== currentPlayer.id && isPlayerVisible(player, visibleArea)) {
 00             visiblePlayers.push(player);
 01         }
 02     });
 03 
 04     return visiblePlayers;
 05 }
 06 
 07 function isPlayerVisible(player, visibleArea) {
 08     return Object.values(gameState.tiles).some(tile => {
 09         return tile.player_id === player.id &&
 10             tile.x >= visibleArea[0][0] && tile.x <= visibleArea[1][0] &&
 11             tile.y >= visibleArea[0][1] && tile.y <= visibleArea[1][1];
 12     });
 13 }
 14 
 15 function formatTime(joinTime) {
 16     const totalSeconds = Math.floor((Date.now() - joinTime) / 1000);
 17     const hours = Math.floor(totalSeconds / 3600);
 18     const minutes = Math.floor((totalSeconds % 3600) / 60);
 19     const seconds = totalSeconds % 60;
 20     return `${hours}h ${minutes}m ${seconds}s`;
 21 }
, there was at least one mismatch.
